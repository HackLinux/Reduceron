module Lava.Verilog(writeVerilog) where

import Lava.Bit
import Lava.Binary
import System

verilogModuleHeader :: String -> Netlist -> String
verilogModuleHeader name nl =
  "module " ++ name ++ "(\n"
  ++ consperse ",\n"
       ([ "  input " ++ v | v <- "clock":inps] ++
        [ "  output " ++ v | v <- outs])
  ++ ");\n\n"
  where
    inps = [ lookupParam (netParams net) "name"
           | net <- nets nl, netName net == "name"]
    outs = map fst (namedOutputs nl)

data Part =
  Part {
    partName       :: String
  , partFamily     :: String
  , partPackage    :: String
  , partSpeedGrade :: String
  }

v5110t :: Part
v5110t =
  Part {
    partName       = "xc5vlx110t"
  , partFamily     = "virtex5"
  , partPackage    = "ff1136"
  , partSpeedGrade = "-1"
  }

ramFile :: Part -> String -> String -> [Parameter] -> String
ramFile part name ramType params = unlines commands
  where
    init = read (lookupParam params "init") :: [Integer]
    dwidth = read (lookupParam params "dwidth") :: Int
    awidth = read (lookupParam params "awidth") :: Int
    primType = lookupParam params "primtype"

    coeFile = if null init then "no_coe_file_loaded"
                           else "init_" ++ name ++ ".txt"

    commands =
      [ "I have no idea what's supposed to go here" ]


verilogDecls :: Netlist -> String
verilogDecls nl =
  "  wire " ++
     (consperse ";\n  wire "
        [ consperse ", " $ map (wireStr . (,) (netId net)) [0..netNumOuts net - 1]
        | net <- wires ]) ++ ";\n" ++
  "  reg " ++
     (consperse ";\n  reg "
        [ consperse ", " $ map (regFormat net) [0..netNumOuts net - 1]
        | net <- regs ]) ++ ";\n"
  where
    regFormat net 0 = wireStr (netId net, 0) ++ " = " ++ init net
    regFormat net y = error "unexpected output arity of a register"

    -- I'm sure there's a "partition" function for this
    wires = [ net | net <- nets nl
            , netName net /= "delay" && netName net /= "delayEn" ]
    regs = [ net | net <- nets nl
            , netName net == "delay" || netName net == "delayEn" ]
    init :: Net -> String
    init net = lookupParam (netParams net) "init"

type Instantiator = String -> [Parameter] -> InstanceId -> [Wire] -> String

verilogInsts :: Netlist -> String
verilogInsts nl =
  concat [ verilogInst (netName net)
             (netParams net)
             (netId net)
             (netInputs net)
         | net <- nets nl ] ++
  concat [ "  assign " ++ s ++ " = " ++ wireStr w ++ ";\n"
         | (s, w) <- namedOutputs nl ]

verilogInst :: Instantiator
verilogInst "low"     = constant "'0'"
verilogInst "high"    = constant "'1'"
verilogInst "inv"     = gate 1 "~"
verilogInst "and2"    = gate 1 "&"
verilogInst "or2"     = gate 1 "|"
verilogInst "xor2"    = gate 1 "^"
verilogInst "eq2"     = gate 1 "=="
verilogInst "xorcy"   = gate 1 "^" -- makes no distinction between xorcy and xor2
verilogInst "muxcy"   = muxcyInst
verilogInst "name"    = assignName
verilogInst "delay"   = delay "fd"
verilogInst "delayEn" = delay "fde"
verilogInst "ram"     = instRam
verilogInst "dualRam" = instRam2
verilogInst s = error ("Verilog: unknown component '" ++ s ++ "'")

muxcyInst params dst [ci,di,s] =
  "  assign " ++ wireStr (dst, 0) ++ " = " ++
  wireStr s ++ " ? " ++ wireStr ci ++ " : " ++ wireStr di ++ ";\n"

ramFiles :: Part -> Netlist -> [(String, String)]
ramFiles part nl =
    [ ( "init_ram_" ++ compStr (netId net) ++ ".txt"
      , genCoeFile $ netParams net)
    | net <- nets nl
    , netName net == "ram" || netName net == "dualRam"
    , nonEmpty (netParams net)
    ]
 ++ [ ( "ram_" ++ compStr (netId net) ++ ".xco"
      , ramFile part
                ("ram_" ++ compStr (netId net))
                (netName net)
                (netParams net))
    | net <- nets nl
    , netName net == "ram" || netName net == "dualRam"
    ]
  where
    nonEmpty params = not (null init)
      where init = read (lookupParam params "init") :: [Integer]

    genCoeFile params =
         "memory_initialization_radix = 10;\n"
      ++ "memory_initialization_vector = "
      ++ (unwords $ map show init)
      ++ ";\n"
     where init = read (lookupParam params "init") :: [Integer]

verilog :: Part -> String -> Netlist -> [(String, String)]
verilog part name nl =
  [ (name ++ ".v",

     "// Generated by York Lava for Verilog\n"
     ++ verilogModuleHeader name nl
     ++ verilogDecls nl
     ++ verilogInsts nl
     ++ "endmodule\n") ]

  ++ ramFiles part nl

{-|

For example, the function

> halfAdd :: Bit -> Bit -> (Bit, Bit)
> halfAdd a b = (sum, carry)
>   where
>     sum   = a <#> b
>     carry = a <&> b

can be converted to a VERILOG entity with inputs named @a@ and @b@ and
outputs named @sum@ and @carry@.

> synthesiseHalfAdd :: IO ()
> synthesiseHalfAdd =
>   writeVerilog "HalfAdd"
>             (halfAdd (name "a") (name "b"))
>             (name "sum", name "carry")

The function 'writeVerilog' assumes that the part (FPGA chip) you are
targetting is the @Virtex-5-110t-ff1136-1@, because that is what sits
at my desk.  This is /only/ important if your design contains RAMs.
If your design does contain RAMs, and you wish to target a different
part, then use the 'writeVerilogForPart' function.  Xilinx's fault!

-}
writeVerilog ::
  Generic a => String -- ^ The name of VERILOG entity, which is also the
                      -- name of the directory that the output files
                      -- are written to.
            -> a      -- ^ The Bit-structure that is turned into VERILOG.
            -> a      -- ^ Names for the outputs of the circuit.
            -> IO ()
writeVerilog = writeVerilogForPart v5110t

-- | Like 'writeVerilog', but allows the target part (FPGA chip) to be specified.
writeVerilogForPart ::
  Generic a => Part   -- ^ Part (FPGA chip) being targetted.
            -> String -- ^ The name of VERILOG entity, which is also the
                      -- name of the directory that the output files
                      -- are written to.
            -> a      -- ^ The Bit-structure that is turned into VERILOG.
            -> a      -- ^ Names for the outputs of the circuit.
            -> IO ()
writeVerilogForPart part name a b =
  do putStrLn ("Creating directory '" ++ name ++ "/'")
     system ("mkdir -p " ++ name)
     nl <- netlist a b
     mapM_ gen (verilog part name nl)
     putStrLn "Done."
  where
    gen (file, content) =
      do putStrLn $ "Writing to '" ++ name ++ "/" ++ file ++ "'"
         writeFile (name ++ "/" ++ file) content

-- Auxiliary functions

compStr :: InstanceId -> String
compStr i = "c" ++ show i

wireStr :: Wire -> String
wireStr (i, 0) = "w" ++ show i
wireStr (i, j) = "w" ++ show i ++ "_" ++ show j

consperse :: String -> [String] -> String
consperse s [] = ""
consperse s [x] = x
consperse s (x:y:ys) = x ++ s ++ consperse s (y:ys)

argList :: [String] -> String
argList = consperse ","

gate 1 str params comp [i1,i2] =
  "  assign " ++ dest ++ " = " ++ x ++ " " ++ str ++ " " ++ y ++ ";\n"
  where dest = wireStr (comp, 0)
        [x,y] = map wireStr [i1,i2]

gate n str params comp [i] =
  "  assign " ++ dest ++ " = " ++ str ++ wireStr i ++ ";\n"
  where dest = wireStr (comp, 0)

gate n str params comp inps = error $ "gate wasn't expecting " ++ str ++ "," ++ show inps

assignName params comp inps =
  "  wire " ++ wireStr (comp, 0)  ++ " = " ++ lookupParam params "name" ++ ";\n"

muxBit params comp [b, a, sel] =
  "with " ++ wireStr sel ++ " select "
          ++ wireStr (comp, 0)  ++ " <= " ++ wireStr a ++ " when '0',"
                                ++ wireStr b ++ " when '1';\n"

constant str params comp inps =
  wireStr (comp, 0) ++ " <= " ++ str ++ ";\n"

delay :: String -> [Parameter] -> Int -> [Wire] -> String
delay "fd" params comp [_, d] =
  "  always @(posedge clock) "
  ++ wireStr (comp, 0)
  ++ " <= "
  ++ wireStr d
  ++ ";\n"

delay "fde" params comp [_, ce, d] =
  "  always @(posedge clock) if ("
  ++ wireStr ce
  ++ ") "
  ++ wireStr (comp, 0)
  ++ " <= "
  ++ wireStr d
  ++ ";\n"

delay str params comp inps =
  compStr comp ++ " : " ++ str
               ++ " generic map (INIT => '"
               ++ lookupParam params "init" ++ "') "
               ++ "port map ("
               ++ argList (wireStr (comp, 0) :
                    "clock" : map wireStr (tail inps))
               ++ ");\n"

-- Block ram synthesis for Virtex 5 using Xilinx core-generator

busMap :: String -> [Wire] -> [String]
busMap port signals =
  zipWith (\i s -> port ++ "(" ++ show i ++ ") => " ++ wireStr s) [0..] signals

instRam params comp (we:sigs) =
    compStr comp ++ " : entity ram_" ++ compStr comp ++ " "
                 ++ " port map ("
                 ++ " clka => clock, "
                 ++ argList (busMap "dina" dbus1) ++ ","
                 ++ argList (busMap "addra" abus1) ++ ","
                 ++ " wea(0) => " ++ wireStr we ++ ","
                 ++ argList (busMap "douta" outs1)
                 ++ ");\n"
  where
    init = read (lookupParam params "init") :: [Integer]
    dwidth = read (lookupParam params "dwidth") :: Int
    awidth = read (lookupParam params "awidth") :: Int
    primType = lookupParam params "primtype"

    (dbus1, abus1) = splitAt dwidth sigs
    outs1          = map ((,) comp) [0..dwidth-1]

instRam2 params comp (we1:we2:sigs) =
    compStr comp ++ " : entity ram_" ++ compStr comp ++ " "
                 ++ " port map ("
                 ++ " clka => clock, "
                 ++ argList (busMap "dina" dbus1) ++ ","
                 ++ argList (busMap "addra" abus1) ++ ","
                 ++ " wea(0) => " ++ wireStr we1 ++ ","
                 ++ argList (busMap "douta" outs1) ++ ","
                 ++ " clkb => clock, "
                 ++ argList (busMap "dinb" dbus2) ++ ","
                 ++ argList (busMap "addrb" abus2) ++ ","
                 ++ " web(0) => " ++ wireStr we2 ++ ","
                 ++ argList (busMap "doutb" outs2)
                 ++ ");\n"
  where
    init = read (lookupParam params "init") :: [Integer]
    dwidth = read (lookupParam params "dwidth") :: Int
    awidth = read (lookupParam params "awidth") :: Int
    primType = lookupParam params "primtype"

    (dbus, abus)   = splitAt (2*dwidth) sigs
    (abus1, abus2) = splitAt awidth abus
    (dbus1, dbus2) = splitAt dwidth dbus
    outs1          = map ((,) comp) [0..dwidth-1]
    outs2          = map ((,) comp) [dwidth..dwidth*2-1]
